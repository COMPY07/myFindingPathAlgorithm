'''
탐색 방법
1	그래프상에서의 모든 정점의 부모노드를 -1로 초기화하고, 비용은 INF(무한대)값으로 설정한다.
2	시작노드의 비용을 0으로 초기화하고, 시작노드의 부모노드는 시작노드를 가리킨다.
3	현재노드를 기준으로 모든방향의 노드에 대한 비용을 계산한다.
4	비용이 계산된 노드들중 최소비용을 가지는 노드가 다음노드가 된다.
5	다음노드의 부모노드는 현재노드를 가리킨다.
6	3~5을 반복한다.
7	만약 다음노드가 도착노드라면, 탐색을 중지하고 최적의 경로를 계산한다.


최적의 경로를 계산하는 방법
1	도착노드를 스택에 푸쉬(push)한다. (현재 가리키고있는 노드는 부모노드이다.)
2	현재 가리키고있는 노드의 부모노드를 스택에 푸쉬(push)한다.
3	2를 반복한다.
4	만약 현재 가리키고있는 노드와 부모노드가 같다면(시작노드라면) 3을 중지한다.
5	그러면 이 스택은 최적의 경로에 대한 정보를 담고 있게된다.

거리 비용 계산은
비용(f) = 다음노드에서 도착노드까지와의 거리(h) + 다음노드 방향에 대한 비용(g)
을 사용합니다!


큐에 들어갈 노드의 좌표를 x1, y1 이라 하고
도착 노드의 좌표를 x2, y2라 하면

두 노드의 거리는 sqrt((x1 - x2)**2 + (y1-y2)**2)가 됩니당

이 식의 설명은 피타고라스를 배우셨다면 아마 이해하셨을 겁니다

(알아서 설명해주시고용)









2.

A*는 그래프 탐색 알고리즘으로 최단 경로를 탐색하는 알고리즘 입니다.
앞서 배웠던 다익스트라와 유사하긴하지만
차이점은 각 꼭짓점에 대해서 그 꼭짓점을 통과하는
최상위 경로를 '추정'하는 순위값 "휴리스틱 추정값(h(x))"을 사용한다는 것 입니다.

# 대충 사전적 정의로는
# 대충 어림짐작하기, 경험이 부족하거나 합리적 판단이 필요하지 않으며 빠르게 판단하고 싶을 때 사용

# 휴리스틱(heuristics)이란 불충분한 시간이나 정보로 인하여 합리적인 판단을 할 수 없거나,
# 체계적이면서 합리적인 판단이 굳이 필요하지 않은 상황에서 사람들이 빠르게 사용할 수 있게 보다 용이하게 구성된 간편 추론의 방법이다.
# 휴리스틱 알고리즘은 기본적으로 모두 최적해가 될 가능성이 없는 답들을 탐색하는 것을 방지하여 만들어
# 봐야 할 답의 수를 줄이는 것을 목표로 한다.


(
# 하지만 어떠한 방법으로 경우의 수를 최적화할지는 매우 어렵고 실제로 고수분들도
# 문제 풀이에 대해 확신하지 못하기 때문에 가장 나중에 풀거나, 부분 점수를 노리는 경우가 많다고 한다.
)


막 어려운 내용을 앞에서 말했지만 정말 간단히 말해서
다익스트라의 확장판, bfs의 가지치기(휴리스틱) 버전이라고 생각하면 된다

핵심 개념부터 살펴보자...


1. 최소가 되는 지점을 우선 탐색
일단 다익스트라의 확장버전 답게 같이 "우선순위 큐"를 사용한다

2. 앞서 계속 말했던 휴리스틱 추정값 사용

3. openList와 closeList를 이용해 노드를 관리한다.


설명 들어갑니다

1. 휴리스틱 추정값

거리 비용 계산은
비용(f) = 다음노드에서 도착노드까지와의 거리(h) + 다음노드 방향에 대한 비용(g) 을 사용합니다!

f(x) = h(x) + g(x)

h(x) : 출발 노드 n으로부터 도착 노드 n까지의 경로 가중치
g(x) : 노드 n 으로부터 목표 노드까지의 추정 경로 가중치(도착 노드까지의 예상 이동비용)
이 경로 가중치를 계산하는 방법 즉 거리를 계산하는 방법은 오늘 배울 것은 두가지인데
1. 맨하탄 거리 측정법
2. 유클리드 거리 측정법
이렇게 두가지이다 이 중..
유클리드 거리 측정법으로 코드를 작성해볼까 한다.

유클리드 거리는 우리가 어릴 적 배웠던
피타고라스 정리를 안다면 쉽게 접근할 수 있다.
우리가 다루는 차원은 2차원이지만 만약 n차원의 두 점 사이를 구하고 싶다면..
각 차원의 차를 제곱해서 모두 더한값의 제곱근이다.
sqrt((a1-b1)**2 + (a2-b2)**2 + (an-bn)**2) 이렇게 나타낼 수 있다.


2. OpenList와 CloseList
opnelist : 검색 가능성이 있는 노드의 집합
closelist : 이미 검색이 끝난 지점들의 집합

3. 탐색 우선 순위
openlist 내의 f(x) 가중치 값이 가장 작은 노드부터 탐색



바로 간단한 설명을 해보겠다.

현재 A*를 구현할때 여기는 2차원 격자입니다.

1. 출발 노드의 주변 노드 8개를 open list에 추가
2. loop를 도는 중 노드 탐색 우선순위는 f(x)가 가장 작은 노드 in opnelist
3. 선택된 노드는 closedlist에 넣어줍니다. 당연히 openlist에서 제거
breakpoint. 현재 노드가 목표 노드와 같을 때

> 장애물 또는 못 가는 지역 등은 closedlist에 넣어줍니다



-----------------

이렇게 우리는 A*를 구현할 준비가 끝났다 바로 구현하러 가보자


신나게 코드를 짜러 가봅시다.


# A* 알고리즘을 더 개량하면 더욱 최적화된 값을 얻을 수 있다.
# 주변노드 탐색(현재는 사각형) 범위를 바꾸거나 맨해튼 거리가 아닌 유클리디안 거리 측정법을 이용하거나.


'''
import math

from .Algorithms import Algorithms
from UI.BoardType import Type as BT
import pygame as p


# 직각 이동의 cost = 2
# 대각 이동의 cost = 3

class AStar(Algorithms):
    def __init__(self, screen: p.Surface, Board: BT):
        super().__init__(screen, Board)

    def thisGrid(self, Start : tuple, finish : tuple, row : int, col : int):
        from UI.Grid import Grid as grid
        import heapq as hq

        board : grid = self.board
        graph : list = [[None for i in range(row)] for i in range(col)]
        StartNode = Node(None, Start[0], Start[1], 0,
                         int(math.sqrt((Start[0] - finish[0]) ** 2 + (Start[1] - finish[1]) ** 2)))
        graph[Start[1]][Start[0]] = StartNode
        q = [(0, StartNode)]
        openList, closedList = [], []
        dx, dy = [1, 1, 1, -1, -1, -1, 0, 0], [0, 1, -1, 0, 1, -1, 1, -1]
        costs = [2, 3, 3, 2, 3, 3, 2, 2] # 대각선과 직선으로 움직임의 cost를 다르게 줌
        while openList:  # q의 size가 0이 될때가지 반복

            (cost, currentNode) = hq.heappop(q)  # 현재 가중치와 좌표를 가져옴

            if currentNode.getXY() == finish: break  # 현재
            openList.pop(currentNode)
            for i in range(8):
                nx, ny = currentNode.x + dx[i], currentNode.y + dy[i]
                if 0 <= nx < row and 0 <= ny < col:
                    if currentNode in closedList or\
                            board.getBoxbyIndex(nx, ny).colorName == "장애물": continue
                    # h = int(math.sqrt((nx - finish[0]) ** 2 + (ny - finish[1]) ** 2))
                    # g = 1
                    # f = h+g
                    if (nx, ny) not in openList or\
                        graph[ny][nx].g > currentNode.g + costs[i]:  #board.getBoxbyIndex(nx, ny).cost > f:
                        if graph[ny][nx] == None:
                            nextNode = Node(currentNode, nx,ny, costs[i]+currentNode.g,
                                            int(math.sqrt((nx - finish[0]) ** 2 + (ny - finish[1]) ** 2)))
                        else:
                            nextNode = graph[ny][nx]
                            nextNode.update(currentNode.g + costs[i])
                            nextNode.parent = currentNode
                        openList.append((nx, ny))
                        hq.heappush(q, (currentNode.getF()+cost, nextNode))
            closedList.append(currentNode)

        # 밀집도 라는 변수 하나 추가해서 다시 구현하자.....
        # 각각 거리(시간), 성향, 밀집도에 얼마나 중점을 둘거냐에 따라서
        # 3을 곱하고 2를 곱하고 해서
        # 밀집도가 가장 중요하다 생각하면 (밀집도 * 3 + 성향 * 2 + 거리) 이렇게 식을 짤 수 있을 듯

        return -1



class Node:
    def __init__(self, parent, x, y, g, h):
        self.h : int = h
        self.g = g
        self.x = x
        self.y = y
        self.parent = parent
    def getF(self):
        return self.g+self.h
    def update(self, g): self.g = g
    def getXY(self):
        return (self.x, self.y)

'''
소프트웨어의 높은 퀄리티를 위해서 테스트를 진행할때, 테스트 케이스를 작성하여 이에 따라 테스트를 실행하고, 실패율로 품질을 측정하는 
방식을 선택하는 회사가 많음. 하지만 현재(2020.04)까지 제품의 모든 경우의 수가 고려되고 전부 테스트 케이스로 옮겨지는 것은 사실상
현실적으로 불가능함. 이러한 부분은 따라서 수치로 계산되지 못한다.
그렇다면, 이러한 테스트 결과 수치가 소프트웨어의 품질을 증명한다고 할 수 있을까?
테스트 케이스는 시간이 지나며 제품의 기능이 발전하고 늘어갈수록, 같이 늘어난다. 그만큼 테스트 수행 시간도 늘어나기 때문에,
결국 부분적 회귀 테스트 전략을 많이 선택한다. 이러다 보면, 오랫동안 건드려지지 않는 위험요소가 적은 부분도 있을테고, 그 부분의 테스트
케이스들을 계속해서 유지 보수하며 갱신하기는 시간이 지날수록 어마어마한 양의 힘들지만 큰 쓸모가 없을지도 모르는 일이 된다. 또한
이를 따라가지 못하면, 실제 테스트를 수행할 때 테스트 케이스가 최신으로 갱신되지 않은 상태에서 테스트가 실패하는 경우 또한 발생이 가능하다.
다시 말해, 상황에 따라 테스트 케이스를 이용하는 테스트 방식이 시간적 소모가 매우 비효율적일 수 있다는 말이다.

알고리즘(Algorithm)과 휴리스틱(Heuristic)

알고리즘은 정해진 정답을 보장하는 문제를 해결하는 방법이며, 따라야 하는 규칙과 같은 것이다.
휴리스틱(체험적) 또한 이러한 규칙이지만, 경험을 바탕으로 한 일반적/대략적 규칙이며, 항상 문제를 해결하거나, 정답이 보장되는건 아니다.


문을 여는 것에 대한 문제로 예를 들어보자면
휴리스틱은 대부분 문제가 해결된다. "손잡이를 돌리고 문을 연다." 하지만 항상은 아니다.
문을 당겨야 할때도 있고, 손잡이가 돌리는 것이 아니라 버튼을 누르는 방식일 수도 있다.
하지만 이 또한 실패할 수도 있다. 그렇다면 또 다른 휴리스틱을 적용해 보는 것이다. 이러한 휴리스틱들은 어느 
것도 해결책을 무조건 보장하지는 않지만, 문제 해결에는 도움이 된다.

테스트 케이스를 수행하다가, 기능적인 결과는 사실상 통과지만, 매우 세밀하고 사소한 부분 때문에 이 테스트 케이스를 통과 시킬지,
실패시킬지 고민해본 경험이 있을 겁니다 아마. 사람들마다, 팀마다 각자의 방식으로 이행하겠지만, 과연 이것이
빠르고 효율적인 테스트 방법일까? 테스트 케이스들은 대부분 알고리즘 방식으로, 통과 혹은 실패로 결과가 도출될 뿐이다. 테스트 케이스를 
실행하는 것은, 알고리즘을 따르는 것이다. 휴리스틱은 가이드라인 같은 것이며, 따르는 것이 아닌 적용하는 것이다. 그러므로 테스트 케이스를 
작성하는데 휴리스틱을 적용하는 것이 매우 어렵고 , 거의 불가능하다고 볼 수 있다. 그렇게 되면 실패하게 되는 테스트 케이스는 현저히 줄어들 것이다.

제품의 품질은 체험을 바탕으로 테스트 결과나 이슈나 궁금증 등을 이야기로 풀어내야 하는것이 제품의 개발을 위해서 더 효율적이고 
점진적인 테스트 방법, 그리고 테스트 결과를 사용하는 방법이 아닐까 생각해본다.


'''


